\documentclass [12 pt ] {beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amssymb,amsfonts,amsmath,mathtext}
\usepackage{cite,enumerate,float,indentfirst}
\usepackage[export]{adjustbox}
\usepackage{paratype} % шрифты
\usepackage{wrapfig}
\usepackage{parallel}
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}

\usepackage{listings}
\lstset{
    language=Haskell,%  Язык указать здесь
    basicstyle=\small,
    breaklines=true,%
    showstringspaces=false%
    inputencoding=utf8x%
}
\usetheme {metropolis}

\newenvironment<>{examplefirst}[1]{%
  \setbeamercolor{block title}{fg=white,bg=orange!75!black}%
  \begin{block}#2{#1}}{\end{block}}
\newenvironment<>{examplesecond}[1]{%
  \setbeamercolor{block title}{fg=white,bg=blue!75!black}%
  \begin{block}#2{#1}}{\end{block}}

% Небольшие номера слайдов формата i/N
\setbeamerfont{page number in head/foot}{size=\small}
\setbeamertemplate{footline}[frame number]
% Небольшие номера слайдов формата i/N

\usepackage{xcolor}
\usepackage{hyperref}
\definecolor{linkcolor}{HTML}{799B03} % цвет ссылок
\definecolor{urlcolor}{HTML}{799B03} % цвет гиперссылок
 
\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor, %
urlcolor=urlcolor, colorlinks=true}

\title{Генерация экземпляров классов типов \\ 
    на основе экземпляров производных классов в языке Haskell}
\author{\small О.\,Е.~Филиппская }
\institute{\textit{Направление подготовки:} Прикладная математика и информатика\\
\textit{Руководитель:} асс. каф. ИВЭ А.\,М.~Пеленицын\\

\vspace{8pt}

Южный федеральный университет\\
Институт математики, механики и компьютерных наук\\
имени~И.\,И.\,Воровича\\

\vspace{8pt}

Кафедра информатики и вычислительного эксперимента}
\date{ }

\begin {document}
    \maketitle
        
    \begin {frame} {Цель работы}
    
    \begin {examplefirst}{Проблема}
    \begin{itemize}
        \item Applicative Monad Proposal (AMP) вносит предложение
        сделать класс Monad подклассом класса Applicative.
        \item GHC 7.8 $\longrightarrow$ GHC 7.10 --- реализует AMP.
        \item Нарушена обратная совместимость.
    \end{itemize}
    \end {examplefirst}
    
    
    \begin {examplefirst} {Цель}
    \begin{itemize}
    \item Создать программное средство, которое восстановит
        компилируемость программ.
    \end{itemize}
    \end {examplefirst}

    \end {frame}
    
    \begin{frame}{Постановка задачи}
        \begin{enumerate}
            \item Получить синтаксическое дерево программы.
            \item Отфильтровать узлы, соответствующие 
                экземплярам класса \textbf{Monad}.
            \item Изменить нужным образом экземпляр класса \textbf{Monad}
                и добавить, если требуется, экземпляры классов 
                \textbf{Applicative} и \textbf{Functor}.
            \item Сформировать новый файл с текстом программы
                с помощью функций структурной печати 
                (\textit{pretty-printing}).
        \end{enumerate}
        \begin{examplefirst}{Метод решения}
        \begin{itemize}
        \item GHC API --- программный интерфейс компилятора
        \end{itemize}
        \end{examplefirst}
    \end{frame}
    
    \begin{frame}{Задача 1: получить синтаксическое дерево программы}
    \tikzstyle{every node}=[shape=rectangle, rounded corners,%
    top color=orange!75!black,%
    bottom color=orange!75!black, text=white, anchor=west]
    \tikzstyle{selected}=[shape=rectangle, rounded corners,%
    top color=green!75!black,%
    bottom color=green!75!black, text=white]
    \tikzstyle{optional}=[dashed,fill=gray!50]
        \begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {hsModule}
    child { node {hsmodName}}		
    child { node {hsmodExports}}
    child { node {hsmodImports }}
    child { node [selected] {hsmodDecls}
      child { node [selected] {InstD}}
      child { node [selected] {TyClD}}
      child { node [selected] {DerivD}}      
      child { node [selected] {$\ldots$}}
    }
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child { node {hsmodDeprecMessage}}
    child { node {hsmodHaddockModHeader}};
      \end{tikzpicture}
    \end{frame}
    
    \begin{frame}{Задача 2: отфильтровать экземпляры монады}
    
    \end{frame}
    
    \begin {frame}{Задача 3: генерация экземпляров Applicative}
         <Как импорт модуля видит компилятор>
    \end {frame}
    
    \begin {frame}{Задача 3: генерация экземпляров Applicative}
        <как экземпляр аппликатива видит компилятор>
    \end {frame}
    
    \begin{frame}[containsverbatim]{Задача 3: генерация экземпляров}
    \begin{examplefirst}{Пользовательский тип}
        \begin{lstlisting}
newtype Prob a = Prob { getProb ::
                    [(a, Rational)] }
        \end{lstlisting}
    \end{examplefirst}
    
    \begin{examplefirst}{Экземпляр Monad}
        \begin{lstlisting}
instance Monad Prob where  
    return x = Prob [(x,1%1)]  
    m >>= f  = flatten (fmap f m)
    x >> y   = x >>= \_ -> y
        \end{lstlisting}
    \end{examplefirst}

    \end{frame}
    
    \begin{frame}[containsverbatim]{Задача 3: генерация экземпляров Applicative}
        \begin{examplefirst}{Ожидаемый результат}
            \begin{lstlisting}
instance Functor Prob where
    fmap   = liftM

instance Applicative Prob where
    pure   = Prob [(x,1%1)]
    (<*>)  = ap
    x *> y = x >>= \_ -> y

instance Monad Probe where
    return   = pure
    (>>)     = (*>)  
    m >>= f  = flatten (fmap f m)
            \end{lstlisting}
        \end{examplefirst}
    \end{frame}
    
    \begin{frame}{Задача 4: формирование выходного файла}
        \begin{itemize}
        \item \textbf{Outputable} --- класс типов, описанный в GHC API,
            экземпляры которого поддерживают функции структурной печати
            (pretty-printing).
        \item \textbf{HsModule} является экземляром класса 
        \textbf{Outputable}.
        \item \lstinline{ppr :: Outputable a => a -> SDoc}
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Недостатки}
        \begin{enumerate}\itemsep=1cm
            \item Комментарии в выходном файле не сохраняются.
            \item Конструкции \lstinline{case ..  of} на выходе синтаксически
                неверны (ошибка в исходном коде компилятора).
        \end{enumerate}
    \end{frame}

    \begin{frame}{Результаты работы}
        \begin{enumerate}
            \item Получено синтаксическое дерево программы 
                (\textbf{parseModule}).
            \item Полученное дерево проанализировано на наличие 
                экземпляров класса \textbf{Monad} (\textbf{ClsInstDecl}).
            \item Изменены нужным образом экземпляр класса \textbf{Monad}
                и добавлены экземпляры классов 
                \textbf{Applicative} и \textbf{Functor}.
            \item Сформирован новый файл с текстом программы
                с помощью функций структурной печати 
                (\textbf{ppr}).
        \end{enumerate}
        
        \begin{examplefirst}{С работой над утилитой можно ознакомиться:}
            \begin{itemize}
            \item \small{\url{https://github.com/Valoisa/Generate-ancestor-instances/tree/addinginstances}}
            \end{itemize}
        \end{examplefirst}
    \end{frame}
    
\end {document}
