\documentclass [12 pt ] {beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amssymb,amsfonts,amsmath,mathtext}
\usepackage{cite,enumerate,float,indentfirst}
\usepackage[export]{adjustbox}
\usepackage{paratype} % шрифты
\usepackage{wrapfig}
\usepackage{parallel}

\usepackage{listings}
\lstset{
    language=Haskell,%  Язык указать здесь
    basicstyle=\small,
    breaklines=true,%
    showstringspaces=false%
    inputencoding=utf8x%
}
\usetheme {metropolis}

\newenvironment<>{examplefirst}[1]{%
  \setbeamercolor{block title}{fg=white,bg=orange!75!black}%
  \begin{block}#2{#1}}{\end{block}}
\newenvironment<>{examplesecond}[1]{%
  \setbeamercolor{block title}{fg=white,bg=blue!75!black}%
  \begin{block}#2{#1}}{\end{block}}

% Небольшие номера слайдов формата i/N
\setbeamerfont{page number in head/foot}{size=\small}
\setbeamertemplate{footline}[frame number]
% Небольшие номера слайдов формата i/N

\title{Генерация экземпляров классов типов \\ 
    на основе экземпляров производных классов в языке Haskell}
\author{\small О.\,Е.~Филиппская }
\institute{\textit{Направление подготовки:} Прикладная математика и информатика\\
\textit{Руководитель:} асс. каф. ИВЭ А.\,М.~Пеленицын\\

\vspace{8pt}

Южный федеральный университет\\
Институт математики, механики и компьютерных наук\\
имени~И.\,И.\,Воровича\\

\vspace{8pt}

Кафедра информатики и вычислительного эксперимента}
\date{ }

\begin {document}
    \maketitle
        
    \begin {frame} {Цель работы}
    
    \begin {examplefirst}{Проблема}
    \begin{itemize}
        \item Applicative Monad Proposal (AMP) вносит предложение
        сделать класс Monad подклассом класса Applicative.
        \item GHC 7.8 $\longrightarrow$ GHC 7.10 --- реализует AMP.
        \item Нарушена обратная совместимость.
    \end{itemize}
    \end {examplefirst}
    
    
    \begin {examplefirst} {Цель}
    \begin{itemize}
    \item Создать программное средство, которое восстановит
        компилируемость программ.
    \end{itemize}
    \end {examplefirst}

    \end {frame}
    
    \begin{frame}{Постановка задачи}
        \begin{enumerate}
            \item Получить синтаксическое дерево программы.
            \item Отфильтровать узлы, соответствующие 
                экземплярам класса \textbf{Monad}.
            \item Изменить нужным образом экземпляр класса \textbf{Monad}
                и добавить, если требуется, экземпляры классов 
                \textbf{Applicative} и \textbf{Functor}.
            \item Сформировать новый файл с текстом программы
                с помощью функций структурной печати 
                (\textit{pretty-printing}).
        \end{enumerate}
    \end{frame}
    
    \begin{frame}[containsverbatim]{Ожидаемый результат}
        \begin{lstlisting}
instance Functor Foo where
    fmap  = liftM

instance Applicative Foo where
    pure  = {- `return` from `Monad` instance -}
    (<*>) = ap
    (*>)  = {- `>>` from `Monad` instance -}

instance Monad Foo where
    return = pure
    (>>)   = (*>)
        \end{lstlisting}
    \end{frame}
    
    \begin {frame}[containsverbatim]{import Control.Applicative}
        \begin{lstlisting}
importApplicative :: LImportDecl RdrName
importApplicative = noLoc $ ImportDecl { 
        ideclSourceSrc = Nothing
      , ideclName      = noLoc 
      $ mkModuleName "Control.Applicative"
      , ideclPkgQual   = Nothing
      , ideclSource    = False
      , ideclSafe      = False
      , ideclQualified = False
      , ideclImplicit  = False
      , ideclAs        = Nothing
      , ideclHiding    = Nothing } 
        \end{lstlisting}
    \end {frame}
    
    \begin {frame}[containsverbatim]{instance Applicative}
        \begin{lstlisting}
instanceApplicative :: LHsType RdrName 
                -> LHsBinds RdrName
                    -> ClsInstDecl RdrName
instanceApplicative insthead funs = 
    ClsInstDecl { cid_poly_ty       = insthead
                , cid_binds         = funs
                , cid_sigs          = []
                , cid_tyfam_insts   = []
                , cid_datafam_insts = []
                , cid_overlap_mode  = Nothing }
        \end{lstlisting}
    \end {frame}
    
    \begin{frame}{Недостатки}
        \begin{enumerate}\itemsep=1cm
            \item Комментарии в выходном файле не сохраняются.
            \item Конструкции \lstinline{case ..  of} на выходе синтаксически
                неверны (ошибка в исходном коде компилятора).
        \end{enumerate}
    \end{frame}

    \begin{frame}{Результаты работы}
        \begin{enumerate}
            \item Получить синтаксическое дерево программы 
                (\textbf{parseModule}).
            \item Проанализировать пролученное дерево на наличие 
                экземпляров класса \textbf{Monad} (\textbf{ClsInstDecl}).
            \item Изменить нужным образом экземпляр класса \textbf{Monad}
                и добавить, если требуется, экземпляры классов 
                \textbf{Applicative} и \textbf{Functor}.
            \item Сформировать новый файл с текстом программы
                с помощью функций структурной печати 
                (\textit{pretty-printing}).
        \end{enumerate}
    \end{frame}
    
\end {document}
